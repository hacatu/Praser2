1:  Build parser.c, needed by all programs implementing parsers using asts or positions from this library.
2:  Build parser_parser.c, which will be superceded by parser_parser.gen.c when parser code generation is implemented, needed to parse parser descriptions.
3:  Build ast_interpreter.c, which is used to parse text using an ast representing a parser, generated by running parser_parser.
4:  Build parser_runner.c, which is used to link with every compiled parser and set up a position struct to the file specified before calling that parser's start_parser.
5:  Build ast_compiler.c (nyi), which is used to generate c code from an ast of a compiler, similar to ast_interpreter.c.
6:  Build parser_compiler.c (nyi), which combines setting up the position, running the parser, and running ast_compiler.
7:  Link parser_parser.o, ast_compiler.o, and parser_compiler.o to create parser_code_generator.
8:  Run parser_code_generator on parser.pra to generate parser_parser.gen.c.
9.  Redo steps 2, 7, and 8, and check that parser_parser.gen.c is unchanged.
10: Build language_generator.c (nyi), which is useded to generate text matching a language description for automated fuzz and coverage testing purposes.
11: Build parser_tester.c (nyi), which generates and executes tests according to language_generator.o and a parser to test that parser.
12: Test the parser.  I don't know how viable the language_generator/parser_tester approach will be, but there you have it.
13: To make new parsers, parser_code_generator can turn the description into a c file implementing all of the parsing functions.  This c file is then built and
    linked with parser_tester and tested.  parser_runner will probably get modified so that it calls linked in functions from two entry points: the parser,
    start_parser, which it passes a position to the input, and the compiler, or ast consumer, which it passes the ast.  Currently this is print_ast and not configurable.
14: Build some useful parsers like Umbrella.
15: Write and build and test an interpreter for Umbrella and then a compiler.  (I got this fam.)

Note that parser_runner in its current form and ast_interpreter are mainly used for bootstraping.

