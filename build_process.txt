1:  Build parser.c, needed by all programs implementing parsers using asts or positions from this library.  (done)
2:  Build parser_parser.c, which will be superceded by parser_parser.gen.c when parser code generation is implemented, needed to parse parser descriptions.  (done)
3:  Build ast_interpreter.c, which is used to parse text using an ast representing a parser, generated by running parser_parser.  (done)
4:  Build parser_runner.c, which is used to link with every compiled parser and set up a position struct to the file specified before calling that parser's start_parser.  (done)
5:  Build ast_compiler.c, which is used to generate c code from an ast of a compiler, similar to ast_interpreter.c.  (done)
6:  Build parser_compiler.c, which combines setting up the position, running the parser, and running ast_compiler.  (done using LD_PRELOAD with parser_runner)
7:  Link parser_parser.o, ast_compiler.o, and parser_compiler.o to create parser_code_generator.  (done using LD_PRELOAD)
8:  Run parser_code_generator on parser.pra to generate parser_parser.gen.c.  (done using ./parser_runner parser compile src/parser.pra src/modules/generated_parser.c)
9.  Redo steps 2, 7, and 8, and check that parser_parser.gen.c is unchanged.  (done by checking `./parser_runner parser print src/parser.pra` vs `./parser_runner generated print src/parser.pra`)
10: Build language_generator.c, which is useded to generate text matching a language description for automated fuzz and coverage testing purposes.  (done, although nonprintable characters are annoying)
11: Build parser_tester.c, which generates and executes tests according to language_generator.o and a parser to test that parser.  (done using LD_PRELOAD with parser_runner)
12: Test the parser.  I don't know how viable the language_generator/parser_tester approach will be, but there you have it.  (done, but generated parsers never report errors due to the `*` operator eating them)
13: To make new parsers, parser_code_generator can turn the description into a c file implementing all of the parsing functions.  This c file is then built and
    linked with parser_tester and tested.  parser_runner will probably get modified so that it calls linked in functions from two entry points: the parser,
    start_parser, which it passes a position to the input, and the compiler, or ast consumer, which it passes the ast.  Currently this is print_ast and not configurable.  (done)
14: Build some useful parsers like Umbrella.  (done, the first Umbrella parser is done)
15: Write and build and test an interpreter for Umbrella and then a compiler.  (I got this fam.)

Note that parser_runner in its current form and ast_interpreter are mainly used for bootstraping.

